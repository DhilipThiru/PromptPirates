# Software Design Specification (SDS)  
## MCQ Timer Feature  

**Document Version**: 1.0  
**Date**: 2024-06-14  
**Project**: MCQ Quiz Application  
**Module**: Timer Feature  
**Author**: AI-Generated (GitHub Copilot)  
**Reviewed By**: _________________  
**Approved By**: _________________  
**Approval Date**: _________________  

---

### Document History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2024-06-14 | AI-Generated | Initial SDS creation |

---

### Distribution List

| Role | Name | Date Sent |
|------|------|-----------|
| Technical Lead |  |  |
| QA Lead |  |  |
| Product Owner |  |  |
|  |  |  |

---

## 1. Executive Summary

The MCQ Timer Feature introduces configurable timers to the existing MCQ Quiz Application to enforce exam duration limits, improve pacing, and ensure consistent exam experiences across devices. The timer will be visible to candidates, autosave answers periodically, and support auto-submission upon expiry. 

This feature aims to reduce exam overruns by more than 95%, minimize answer loss with autosave success rate of 6499%, and ensure compliance with server-authoritative timing and audit trails. The timer will support accessibility and localization to serve diverse candidates.

Key stakeholders include Product Management, UX, Frontend, Backend, QA, Security, and Support teams. Success will be measured by meeting performance targets, ensuring reliability during transient network issues, and positive candidate feedback regarding timer visibility and accuracy.

---

## 2. Scope & Requirements

### 2.1 Functional Requirements

1. [FR-1] Enforce a time limit for the entire exam using a countdown timer visible to the candidate.  
2. [FR-2] On timer expiry, automatically autosave answers and submit the exam if configured, and lock further edits.  
3. [FR-3] The timer must be visible, accurate, and persist across page reloads and brief network outages.  
4. [FR-4] Log all timing-related events (start, warnings, expiry) for auditing purposes.  
5. [FR-5] Provide an admin interface to configure timer modes, durations, warning thresholds, expiry behaviors, and accommodations.  
6. [FR-6] Support autosave functionality to minimize answer loss.  
7. [FR-7] Ensure timer accessibility and localization for diverse candidate needs.

### 2.2 Non-Functional Requirements

1. [NFR-1] Performance: Timer tick updates every 1 second; UI latency 100 ms.  
2. [NFR-2] Reliability: No answer loss under transient network loss up to 60 seconds.  
3. [NFR-3] Security: Server authoritative timekeeping; prevent client-side clock tampering.  
4. [NFR-4] Scalability: Support large concurrent sessions without degradation.  
5. [NFR-5] Accessibility: Comply with WCAG standards for timer UI components.  
6. [NFR-6] Localization: Support multiple languages and regional formats.

### 2.3 Scope Boundaries

**In Scope:**  
- Exam-level countdown timer.  
- Autosave and auto-submit on expiry.  
- Warning thresholds and notifications.  
- Persistence across refresh and brief network loss.  
- Admin configuration for timer settings and accommodations.

**Out of Scope:**  
- Section-level timers (future enhancement).  
- Deep analytics beyond logging timing events.  
- UI redesign of quiz beyond timer component.

### 2.4 Assumptions and Constraints

- The existing MCQ app is server-authoritative for exam state management.  
- User sessions are maintained via Chainlit session management.  
- Network interruptions are short and recoverable; long outages require separate handling.  
- Admin interface extensions are feasible within existing backend framework.  
- Time synchronization between client and server can be reliably established.

### 2.5 Dependencies

- Chainlit framework for session and messaging features.  
- Backend services for autosave and exam submission APIs.  
- Database for storing timing logs and exam state.  
- Frontend UI components for timer display and notifications.

---

## 3. Architecture Overview

### 3.1 System Context Diagram

The MCQ Timer Feature integrates into the existing MCQ Quiz Application built on Python Chainlit framework. The key system components involved are:

- **Client UI:** Displays the countdown timer, warnings, and notifications to candidates. Sends timing events to server.  
- **Chainlit Backend:** Manages quiz and user session state, enforces timing rules, handles autosave and auto-submit.  
- **Database:** Stores questions, answers, timing logs, and configuration settings.  
- **Admin Dashboard:** Allows configuration of timer parameters and accommodations.  

```mermaid
graph TD
    ClientUI[Client UI (Browser)] -->|User Interactions| ChainlitBackend[Chainlit Backend Server]
    ChainlitBackend -->|Persist Data| Database[(Database)]
    AdminDashboard[Admin Dashboard] -->|Configure Timer| ChainlitBackend
    ClientUI -->|Timer Events| ChainlitBackend
```

### 3.2 Component Interactions

- On exam start, the backend initializes the timer state and sends the initial timer value to the client.  
- The client UI updates the countdown every second and displays warnings at configured thresholds.  
- Timer events (start, warning, expiry) are communicated back to the backend via Chainlit messaging.  
- Autosave API is invoked periodically or on expiry to save candidate answers.  
- On expiry, the backend triggers auto-submission and locks the exam.  
- Admin dashboard reads/writes timer configuration via backend APIs.

### 3.3 Technology Stack

| Layer           | Technology / Framework   |
|-----------------|-------------------------|
| Backend         | Python 3.10+, Chainlit  |
| Frontend        | Chainlit UI Components  |
| Database        | Not explicitly defined (likely relational DB) |
| Admin Interface | Python APIs, Chainlit   |

### 3.4 Integration Points

- Timer autosave and submission API endpoints.  
- User session management via Chainlit.  
- Logging subsystem for audit trail of timing events.  
- Admin configuration storage and retrieval.

---

## 4. Component Breakdown

### 4.1 Timer Manager

**Responsibilities:**  
- Track exam countdown timer per user session.  
- Enforce timer expiry behavior (autosave, submit, lock).  
- Communicate timer ticks and warnings to client UI.  
- Handle persistence across reloads and network interruptions.

**Interfaces:**  
- Timer start/stop API.  
- Event logging interface.  
- Autosave and submit callbacks.

**Design Patterns:**  
- Singleton per user session.  
- Observer pattern for UI updates.  

**Code References:**  
- To be implemented as an extension in `app.py` session handling.  

### 4.2 Client Timer UI Component

**Responsibilities:**  
- Display the countdown timer in fixed header.  
- Show warning notifications and expiry messages.  
- Send timing events to backend.

**Interfaces:**  
- Receive timer state updates from backend via Chainlit messages.  
- Send user interaction or timer acknowledgement events.

**Design Patterns:**  
- Reactive UI component pattern.

**Code References:**  
- New UI components added to Chainlit message flows.

### 4.3 Admin Configuration Module

**Responsibilities:**  
- Provide APIs and UI for configuring timer modes, durations, warnings, expiry behavior, and accommodations.  
- Validate and persist configuration data.

**Interfaces:**  
- REST or Chainlit API endpoints for config CRUD.  
- Data persistence layer.

**Design Patterns:**  
- MVC pattern for admin UI and backend.

**Code References:**  
- To be added in backend API modules.

### 4.4 Persistence Layer

**Responsibilities:**  
- Store timer-related logs and configuration.  
- Maintain autosave snapshots of candidate answers.

**Interfaces:**  
- Database access via ORM or direct queries.

**Design Patterns:**  
- Repository pattern.

**Code References:**  
- Database schema extensions planned.

---

## 5. API Overview

### 5.1 Timer Control Endpoints

| Endpoint              | Method | Description                             | Request Body          | Response          |
|-----------------------|--------|-------------------------------------|-----------------------|-------------------|
| /api/timer/start      | POST   | Initialize and start timer for exam | { exam_id, user_id }   | { timer_start_time, duration } |
| /api/timer/stop       | POST   | Stop and finalize timer              | { exam_id, user_id }   | { status }        |
| /api/timer/status     | GET    | Get current timer status             | Query params: exam_id, user_id | { remaining_time, state } |

### 5.2 Autosave Endpoints

| Endpoint              | Method | Description                        | Request Body          | Response          |
|-----------------------|--------|----------------------------------|-----------------------|-------------------|
| /api/autosave         | POST   | Save current answers snapshot    | { exam_id, user_id, answers } | { status }        |

### 5.3 Exam Submission Endpoint

| Endpoint              | Method | Description                      | Request Body          | Response          |
|-----------------------|--------|--------------------------------|-----------------------|-------------------|
| /api/exam/submit      | POST   | Submit exam on timer expiry     | { exam_id, user_id }   | { submission_status } |

### 5.4 Admin Configuration Endpoints

| Endpoint              | Method | Description                           | Request Body           | Response          |
|-----------------------|--------|-------------------------------------|------------------------|-------------------|
| /api/admin/timer-config | GET    | Get current timer configuration     | N/A                    | { config }        |
| /api/admin/timer-config | POST   | Update timer configuration           | { config_data }        | { status }        |

### 5.5 Authentication & Authorization

- Authentication is handled by existing user session management in Chainlit.  
- Admin endpoints require elevated privileges and role-based access control.

### 5.6 Rate Limiting & Quotas

- To be defined in backend API gateway or Chainlit middleware.  
- Expected low volume per user session.

### 5.7 Error Codes & Handling

| Code | Description                           | Remediation                        |
|-------|------------------------------------|----------------------------------|
| 400   | Bad Request (invalid parameters)   | Validate request data             |
| 401   | Unauthorized                       | Authenticate user                |
| 403   | Forbidden (insufficient rights)    | Check user roles                 |
| 404   | Not Found (exam/session missing)   | Verify exam and user session     |
| 500   | Internal Server Error               | Check backend logs and retry     |

---

## 6. Data Model & Persistence

### 6.1 Database Schemas

The timer feature requires extending the existing database schema to support timer states, logs, and autosave data.

| Table Name           | Description                               | Key Columns                             |
|---------------------|-------------------------------------------|---------------------------------------|
| exam_timer          | Stores timer start, duration, and status | exam_id (FK), user_id (FK), start_time, duration, state |
| timer_logs          | Audit log for timer events                | log_id (PK), exam_id (FK), user_id (FK), event_type, timestamp |
| autosave_snapshots  | Stores periodic answer snapshots          | snapshot_id (PK), exam_id (FK), user_id (FK), answers_json, timestamp |

### 6.2 Entity Relationships

- An exam_timer record belongs to one exam and one user session.  
- timer_logs track multiple events per timer instance.  
- autosave_snapshots capture candidate answers at intervals.

```mermaid
erDiagram
    EXAM_TIMER {
        int exam_id PK FK
        int user_id PK FK
        datetime start_time
        int duration
        string state
    }
    TIMER_LOGS {
        int log_id PK
        int exam_id FK
        int user_id FK
        string event_type
        datetime timestamp
    }
    AUTOSAVE_SNAPSHOTS {
        int snapshot_id PK
        int exam_id FK
        int user_id FK
        json answers_json
        datetime timestamp
    }
    
    EXAM_TIMER ||--o{ TIMER_LOGS : has
    EXAM_TIMER ||--o{ AUTOSAVE_SNAPSHOTS : has
```

### 6.3 Data Validation Rules

- Timer duration must be positive integer (seconds).  
- Event types must be one of: START, WARNING, EXPIRED, AUTOSAVE.  
- Answers JSON must adhere to quiz question schema.  
- Timestamp fields must be validated for consistency.

### 6.4 Migration Strategy

- Add new tables for timer and logs using migration scripts.  
- Deploy schema changes prior to feature rollout.  
- Backfill any existing exam sessions if needed (optional).  
- Test migrations on staging environment before production.

### 6.5 Data Retention Policies

- Timer logs and autosave snapshots retained for audit period (e.g., 1 year).  
- Older records archived or purged according to compliance.

---

## 7. Configuration & Deployment

### 7.1 Environment Variables

| Variable Name            | Description                              | Default | Required |
|-------------------------|------------------------------------------|---------|----------|
| TIMER_ENABLE            | Enable or disable timer feature          | true    | Yes      |
| TIMER_DEFAULT_DURATION  | Default exam timer duration (seconds)   | 3600    | Yes      |
| TIMER_WARNING_THRESHOLDS| Comma-separated warning times (seconds) | 300,60  | Yes      |
| AUTOSAVE_INTERVAL       | Autosave interval in seconds             | 60      | Yes      |
| MAX_NETWORK_OUTAGE      | Max allowed network outage (seconds)     | 60      | Yes      |

### 7.2 Configuration Files

- Configuration stored in backend config files (YAML/JSON) and environment variables.  
- Admin UI provides overrides stored in database.

### 7.3 Deployment Steps

- Deploy database schema migrations.  
- Deploy updated backend with timer APIs and logic.  
- Deploy updated client UI with timer components.  
- Deploy admin dashboard updates.  
- Run integration and load tests.  
- Monitor logs and metrics post-deployment.

### 7.4 Infrastructure Requirements

- Backend server scaling to handle additional timer and autosave requests.  
- Database storage for logs and snapshots.  
- Monitoring and alerting for timer-related failures.

### 7.5 Scaling Considerations

- Use caching for frequent timer state reads.  
- Autosave batching to reduce DB writes.  
- Load balancing backend API endpoints.

---

## 8. Security & Compliance

### 8.1 Authentication Mechanisms

- Uses existing Chainlit user session authentication.  
- Admin API endpoints protected with role-based access control.

### 8.2 Authorization and Access Control

- Candidates can only access their own timer and exam data.  
- Admin users have elevated privileges for configuration.

### 8.3 Data Encryption

- All API communication encrypted via HTTPS/TLS.  
- Sensitive data in database encrypted at rest according to organizational policy.

### 8.4 Input Validation and Sanitization

- Validate all client inputs for timer configuration and autosave data.  
- Sanitize inputs to prevent injection attacks.

### 8.5 Compliance Requirements

- Server-authoritative timing to prevent client clock tampering.  
- Audit logging of all timer events for compliance and traceability.  
- Data retention policies aligned with GDPR and other relevant regulations.

### 8.6 Audit Logging

- Detailed logs of timer events stored securely.  
- Logs accessible for auditing by authorized personnel.

### 8.7 Threat Modeling

- Potential threats include client-side time manipulation, session hijacking, and denial of service on autosave endpoints.  
- Mitigations include server-side enforcement of time, secure session management, and rate limiting.

---

## 9. Observability

### 9.1 Logging Strategy

- Log timer events (start, warnings, expiry) with timestamps and user identifiers.  
- Log autosave success/failure events.  
- Log errors and exceptions in timer processing.

### 9.2 Monitoring and Alerting

- Monitor timer API latencies and error rates.  
- Alert on autosave failures or submission errors.  
- Track timer accuracy metrics and UI update latencies.

### 9.3 Performance Metrics

| Metric                 | Description                    | Target               |
|------------------------|--------------------------------|----------------------|
| Timer tick latency     | Time between timer ticks       | 100 ms             |
| Autosave success rate  | Percentage of successful autosaves | 6499%               |
| Timer expiry accuracy | Deviation between server and client expiry | 1 second          |

### 9.4 Health Checks

- Backend health endpoints include timer subsystem status.  
- Client UI health includes timer rendering and update checks.

### 9.5 Debugging Approaches

- Enable debug logs for timer flows during testing.  
- Use distributed tracing for API calls related to timer and autosave.  
- Provide admin dashboard with timer status diagnostics.

---

## 10. Non-Functional Requirements

### 10.1 Performance Targets

- Timer UI updates every 1 second with latency 100 ms.  
- Autosave API responds within 200 ms under normal load.

### 10.2 Scalability Requirements

- Support 1000+ concurrent exam sessions with timer enabled.  
- Autosave endpoints handle batch requests efficiently.

### 10.3 Reliability and Availability

- Timer feature must have 99.9% uptime during exam periods.  
- Failover mechanisms for autosave and submission services.

### 10.4 Disaster Recovery

- Backup timing logs and autosave data regularly.  
- Restore procedures tested to minimize data loss.

### 10.5 Accessibility

- Timer UI complies with WCAG 2.1 AA standards.  
- Supports screen readers and keyboard navigation.

### 10.6 Internationalization & Localization

- Timer messages and warnings localized into supported languages.  
- Time formats adapted to user locale settings.

---

## 11. Risks & Mitigation

### 11.1 Technical Risks

| Risk                               | Impact                       | Mitigation Strategy                            |
|-----------------------------------|------------------------------|-----------------------------------------------|
| Client-side clock tampering       | Incorrect timer enforcement  | Server-authoritative timing, validate on backend |
| Network outages during exam       | Answer loss or timer desync  | Autosave, timer persistence, max outage tolerance |
| Autosave API overload             | Performance degradation      | Autosave batching, rate limiting              |
| Database storage growth           | Storage cost and performance | Archiving and purging old logs and snapshots  |
| Inaccurate timer synchronization | Candidate confusion          | Periodic server sync, UI warnings              |

### 11.2 Known Limitations

- Section timers are not included in this release; only exam-level timer supported.  
- Long network outages beyond configured threshold may cause timer inaccuracies.  
- Autosave relies on client connectivity; offline support limited.

### 11.3 Technical Debt

- Integration of timer into legacy code may require refactoring.  
- Admin UI extensions may need redesign for scalability.

### 11.4 Dependency Risks

- Chainlit framework updates could impact session or messaging behavior.  
- Backend API stability critical for autosave and submission.

### 11.5 Contingency Plans

- Provide manual override for exam submission in case of timer failure.  
- Rollback database migrations if critical bugs found.  
- Monitor logs closely for early detection of timer issues.

### 11.6 Migration/Rollback Strategy

- Migrate schema with backward compatibility.  
- Deploy timer feature in staged rollout.  
- Rollback code and schema changes if major defects arise.

---

## 12. Architecture Decision Records (ADRs)

### ADR-001: Timer Enforcement Strategy

**Status**: Accepted  
**Date**: 2024-06-14  
**Deciders**: Architecture Team  

#### Context  
Preventing client-side clock tampering requires server-authoritative timer enforcement.

#### Decision Drivers  
- Security and compliance requirements.  
- Candidate fairness and exam integrity.

#### Considered Options  
1. Client-only timer enforcement.  
2. Server-authoritative timer with client updates.  
3. Hybrid approach with server validation and client display.

#### Decision Outcome  
Chosen option: 2 - Server-authoritative timer with client updates.  
Positive Consequences:  
- Prevents timer manipulation.  
- Provides audit trail.  
Negative Consequences:  
- Requires backend complexity.  
- Potential network dependency.

#### Links  
- Related ADR-002 (Autosave mechanism)

---

### ADR-002: Autosave Implementation

**Status**: Proposed  
**Date**: 2024-06-14  
**Deciders**: Development Team  

#### Context  
Minimizing answer loss during network instability requires autosave.

#### Decision Drivers  
- User experience reliability.  
- Network instability tolerance.

#### Considered Options  
1. Client-side autosave only.  
2. Server-side autosave with frequent client updates.  
3. Combined client-server autosave with fallback.

#### Decision Outcome  
Chosen option: 3 - Combined autosave with fallback.  
Positive Consequences:  
- High reliability.  
- Reduced data loss.  
Negative Consequences:  
- Increased implementation complexity.

---

### ADR-003: Timer UI Placement

**Status**: Accepted  
**Date**: 2024-06-14  
**Deciders**: UX Team  

#### Context  
Timer visibility is critical for candidate awareness.

#### Decision Drivers  
- User experience standards.  
- Accessibility requirements.

#### Considered Options  
1. Fixed header timer.  
2. Floating timer widget.  
3. Inline timer near questions.

#### Decision Outcome  
Chosen option: 1 - Fixed header timer.  
Positive Consequences:  
- Always visible.  
- Consistent UX.  
Negative Consequences:  
- Uses fixed UI space.

---

## 13. Assumptions & Constraints

### 13.1 Assumptions

- Candidates have stable internet connections with occasional short outages.  
- Backend services can handle additional autosave and timer requests.  
- Admin users have necessary permissions for configuration.  
- Timer and autosave data will be stored securely.

### 13.2 Constraints

- Timer accuracy limited by network latency and client clock.  
- Autosave frequency balanced against server load.  
- UI modifications limited to Chainlit framework capabilities.  
- Deployment scheduled to minimize disruption.

---

## 14. Dependencies & Integration

### 14.1 Internal Dependencies

- Chainlit session management and messaging framework.  
- Backend exam management APIs.  
- Database schema extensions.

### 14.2 External Dependencies

- None for timer feature in current scope.

### 14.3 Database Dependencies

- New tables for timer and logs must be added and maintained.  
- Existing exam and user tables referenced.

### 14.4 Infrastructure Dependencies

- Backend servers must scale to handle timer and autosave load.  
- Monitoring and alerting infrastructure.

### 14.5 Build/Deployment Dependencies

- CI/CD pipelines updated for schema migrations and API deployments.

### 14.6 Dependency Version Matrix

| Component      | Version         |
|----------------|-----------------|
| Python         | 3.10+           |
| Chainlit       | >=2.9.0         |
| Database       | Compatible SQL DB |

### 14.7 Integration Sequence

1. Deploy schema migrations.  
2. Deploy backend timer and autosave APIs.  
3. Deploy client UI updates.  
4. Deploy admin dashboard updates.  
5. Monitor and verify system stability.

---

## 15. Glossary & References

### 15.1 Glossary

| Term       | Definition                                     |
|------------|------------------------------------------------|
| Autosave   | Automatic saving of candidate answers periodically. |
| Chainlit   | Python framework for building chat apps and interactive UIs. |
| Timer Expiry | The point when the countdown timer reaches zero. |
| Warning Threshold | Configured times before expiry to warn candidate. |
| Server-Authoritative | The backend server controls and validates timer state. |

### 15.2 References

- Business Requirements Specification (BRS) for MCQ Timer Feature: [BRS Document](https://github.com/DhilipThiru/PromptPirates/blob/dev/BRS/Business%20Requirement%20Specification%20MCQ%20Timer%20Feature.docx)  
- Chainlit Documentation: https://chainlit.io/  
- WCAG 2.1 Accessibility Guidelines: https://www.w3.org/TR/WCAG21/  
- GDPR Compliance: https://gdpr-info.eu/  

---

## 16. Appendices

### 16.1 Appendix A: Timer Warning Levels

| Warning Level | Time Remaining (seconds) | Notification Type       | Description                                   |
|---------------|-------------------------|------------------------|-----------------------------------------------|
| Normal        | > Warning Threshold 1   | None                   | Timer running normally                        |
| Warning 1     | ≤ Warning Threshold 1   | Non-blocking banner    | First warning to candidate                    |
| Warning 2     | ≤ Warning Threshold 2   | Non-blocking banner + Sound (optional) | Critical warning before expiry                |
| Expired       | 0                       | Modal + Auto-submit    | Timer expired; exam auto-submitted and locked |

### 16.2 Appendix B: Autosave Interval Recommendations

- Autosave frequency default: 60 seconds.  
- Increased frequency may impact server performance.  
- Adjust based on exam length and network conditions.

### 16.3 Appendix C: Timer UI Mockups

- Fixed header displaying countdown in HH:MM:SS format.  
- Warning banners displayed below header.  
- Expired state overlay locking inputs.

### 16.4 Appendix D: API Payload Examples

```json
POST /api/timer/start
{
  "exam_id": "1234",
  "user_id": "5678"
}

Response:
{
  "timer_start_time": "2024-06-14T15:00:00Z",
  "duration": 3600
}
```

```json
POST /api/autosave
{
  "exam_id": "1234",
  "user_id": "5678",
  "answers": [
    {"question_id": 1, "answer": 2},
    {"question_id": 2, "answer": 1}
  ]
}

Response:
{
  "status": "success"
}
```

---

## 17. Instructions & Next Steps

### 17.1 Development

- Implement Timer Manager and integrate with Chainlit backend.  
- Develop client UI timer components with accessibility features.  
- Extend admin dashboard with timer configuration interfaces.  
- Create backend APIs for timer control, autosave, and submission.

### 17.2 Testing

- Unit test timer logic and autosave functionality.  
- Integration test full exam timer flows including expiry and warnings.  
- Load test autosave endpoints for scalability.  
- Accessibility test UI components for WCAG compliance.  
- Security test server authoritative timing enforcement.

### 17.3 Deployment

- Apply database migrations in staging environment.  
- Deploy backend and client updates.  
- Monitor system for errors and performance issues.  
- Collect user feedback for improvements.

---

## 18. Word Conversion Instructions

To convert this Markdown document to Word format, use Pandoc:

### Prerequisites
- Install Pandoc: https://pandoc.org/installing.html  
  - Windows: `choco install pandoc` or download installer  
  - Mac: `brew install pandoc`  
  - Linux: `apt-get install pandoc` or `yum install pandoc`  

### Conversion Commands

**Basic Conversion**:  
```bash
pandoc docs/SDS_MCQ_Timer_Feature_20240614.md -o docs/SDS_MCQ_Timer_Feature_20240614.docx
```

**With Table of Contents**:  
```bash
pandoc docs/SDS_MCQ_Timer_Feature_20240614.md -o docs/SDS_MCQ_Timer_Feature_20240614.docx --toc --toc-depth=3
```

**With Custom Styling** (requires reference.docx template):  
```bash
pandoc docs/SDS_MCQ_Timer_Feature_20240614.md -o docs/SDS_MCQ_Timer_Feature_20240614.docx --reference-doc=custom-reference.docx --toc
```

### Mermaid Diagrams in Word
Mermaid diagrams must be manually converted:  
1. Copy Mermaid code to https://mermaid.live/  
2. Export as PNG/SVG  
3. Insert images into Word document  

---
